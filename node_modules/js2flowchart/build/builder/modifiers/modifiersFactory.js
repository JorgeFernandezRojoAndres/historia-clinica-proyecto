function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import { TOKEN_TYPES, TOKEN_KEYS, MODIFIED_TYPES } from 'shared/constants';
var extractNodeName = function extractNodeName(node, field) {
  var name = node.name.split(".".concat(field, "("))[0];
  if (name.includes('=')) {
    return name.split('=');
  }
  return [name];
};
var testNode = function testNode(node, field) {
  return node.name.includes(".".concat(field, "("));
};
export var DEFINED_MODIFIERS = {
  forEach: {
    test: function test(node) {
      return testNode(node, 'forEach');
    },
    updates: {
      name: function name(node) {
        return "each in  ".concat(extractNodeName(node, 'forEach')[0]);
      },
      type: TOKEN_TYPES.LOOP,
      body: function body(node) {
        return _toConsumableArray(node.body[0].body);
      }
    }
  },
  filter: {
    test: function test(node) {
      return testNode(node, 'filter');
    },
    updates: {
      name: function name(node) {
        return "in ".concat(extractNodeName(node, 'filter')[1], " to ").concat(extractNodeName(node, 'filter')[0]);
      },
      prefixName: 'filter',
      type: TOKEN_TYPES.LOOP
    }
  },
  map: {
    test: function test(node) {
      return testNode(node, 'map');
    },
    updates: {
      name: function name(node) {
        return "from ".concat(extractNodeName(node, 'map')[1], " to ").concat(extractNodeName(node, 'map')[0]);
      },
      prefixName: 'map',
      type: TOKEN_TYPES.LOOP
    }
  }
};
export var destructionModifier = function destructionModifier(test, newNameFn) {
  return {
    test: test,
    updates: {
      name: newNameFn,
      body: [],
      type: MODIFIED_TYPES.DESTRUCTED
    }
  };
};
export var arrowFunctionReturnModifier = function arrowFunctionReturnModifier() {
  return {
    test: function test(node) {
      return node.isBodyEntry && node.parent && node.parent.subType === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION;
    },
    updates: {
      name: function name(node) {
        return 'return ' + node.name;
      },
      type: TOKEN_TYPES.RETURN
    }
  };
};
export var expressionCallbacksModifier = function expressionCallbacksModifier() {
  return {
    test: function test(node) {
      return node.pathParentType === TOKEN_TYPES.CALL_EXPRESSION;
    },
    updates: {
      subTreeUpdate: function subTreeUpdate(nodes) {
        nodes.forEach(function (node) {
          var parentBody = node.parent.body,
            index = parentBody.indexOf(node) + 1;
          for (var i = index; i < parentBody.length; i++) {
            var sibling = parentBody[i];
            if (sibling && sibling.type === TOKEN_TYPES.CALL_EXPRESSION) {
              node.parent.body = parentBody.filter(function (n) {
                return n !== node;
              });
              sibling.body = [].concat(_toConsumableArray(sibling.body || []), [node]);
              return;
            }
          }
        });
      }
    }
  };
};
export var MODIFIER_PRESETS = {
  es5ArrayIterators: [DEFINED_MODIFIERS.forEach, DEFINED_MODIFIERS.filter, DEFINED_MODIFIERS.map]
};